#!/bin/bash
# Copyright 2018 Walentin Lamonos lamonos@lrz.de
# Based on repairRoutes.sh by Tobias Weber weber@lrz.de
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Script that handles the setup of systemd-networkd and systemd-resolved
# IPs are stored as IP_ARRAY[0] = IP[[:space:]]CIDR[[:space:]]BROADCAST[[:space:]]DEVICENAME
#      Example: 141.40.254.115 23 141.40.255.255 {{ NICDEVICEPREFIX_NEBULA }}3

########################
# FUNCTION DEFINITIONS #
########################
# Return netmask for a given network and CIDR.
# Taken from https://gist.github.com/kwilczynski/5d37e1cced7e76c7c9ccfdf875ba6c5b
# Arguments:
#   $1 = IP
#   $2 = CIDR
cidr_to_netmask() {
  local value=$(( 0xffffffff ^ ((1 << (32 - $1)) - 1) ))
  echo "$(( (value >> 24) & 0xff )).$(( (value >> 16) & 0xff )).$(( (value >> 8) & 0xff )).$(( value & 0xff ))"
}

# Returns the network address given an ip and subnet mask
# Taken from https://stackoverflow.com/a/15429733
# Arguments:
#   $1 = IP
#   $2 = SUBNET_MASK
ip_to_netaddr() {
  IFS=. read -r i1 i2 i3 i4 <<< "$1"
  IFS=. read -r m1 m2 m3 m4 <<< "$2"
  echo "$(printf "%d.%d.%d.%d\n" "$((i1 & m1))" "$((i2 & m2))" "$((i3 & m3))" "$((i4 & m4))")"
  unset $IFS
}

# Delete default network config of VMWare 
clean_vmware_netconfig() {
 # Delete file, or ignore if already deleted
 rm /etc/systemd/network/wired.network > /dev/null 2>&1
}

# Test if we are already set up
# This ensures successive runs of the task, don't break
# an already setup machine.
check_if_already_setup() {
  DIRECTORYTEST=$(find /etc/systemd/network -name "*.network" | wc -l)
  # If we have more than one *.network file (Note: We delete VMWare's default ealier)
  if [ "$DIRECTORYTEST" -ge "1" ]; then
    echo "Networkd already setup. Nothing to do here."
    exit 0;
  fi
}

# Validates the input parameters
validate_input_parameters() {
  # Check if routing table is not zero
  if [ -z "$ROUTING_TABLE_INT" ]; then
    >&2 echo "Error: No ROUTING_TABLE_INT passed to the script. This is required! Aborting."
    exit 1
  fi
  # Check if nfs server domain is not zero
  if [ -z "$NFS_SERVER_DOMAIN" ]; then
    >&2 echo "Error: No NFS_SERVER_DOMAIN passed to the script. This is required! Aborting."
    exit 1
  fi
  # Check if routing table is number
  re='^[0-9]+$'
  if ! [[ $ROUTING_TABLE_INT =~ $re ]]; then
    >&2 echo "Error: ROUTING_TABLE_INT not a number"
    exit 1
  fi
}

# Filter out ipv4 ips
# Remove loopback, filter by device {{ NICDEVICEPREFIX_NEBULA }}0-9
# Get the fields we need, replace / with space
# Filter out dynamic
build_ip_arrays() {
  IFS=$'\n'
  IP_ARRAY=$( \
    ip addr | grep -e "inet[[:space:]]" | \
    grep -v '127.0.0.1' | grep -E '{{ NICDEVICEPREFIX_NEBULA }}[0-9]' | \
    awk '{print $2" "$4" "$7$8}' | sed 's/\// /g' | \
    sed 's/dynamic//g')
  unset $IFS
  # Split into private and public IPs
  # Also calculate gateways
  while read -r IP; do
    # Get the gateway address (for LRZ it's broadcast - 1)
    GATEWAYS+=$(echo $IP | awk '{print $3}' | awk -F"." '{printf "%d.%d.%d.%d ", $1, $2, $3, $4 - 1}')
    # Check if IP matches the private IP patterns
    TMP=$(echo $IP | awk '{print $1}' | grep -E '^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.)') # Taken from: https://unix.stackexchange.com/a/98930
    if [ -z "$TMP" ]; then
      # Public IP
      PUBLIC_IPS+=("$IP")
    else
      # Private IP
      PRIVATE_IPS+=("$IP")
    fi
  done <<< "$IP_ARRAY"
  # Check what state we are in
  # Loadbalancers: 1 Public & 1 Private -> Setup required
  # Nodes: 0 Public & 1 Private interface -> Setup required
{% raw %}
  echo "${#PUBLIC_IPS[@]} Public & ${#PRIVATE_IPS[@]} Private IPs detected."
{% endraw %}
}

# Error states
# Makes sure we have enough IPs
validate_ip_count() {
{% raw %}
  if [ ${#PRIVATE_IPS[@]} -eq 0 ]; then
    >&2 echo "Error: No private IPs assigned to node. All setups require private IPs!"
    exit 1
  fi
{% endraw %}
}

{% if inventory_hostname in groups['loadbalancer-nodes'] %}
# LB ONLY
# Add a ip rule to allow access to the NFS server
add_nfs_ip_rule() {
  EXIST=`ip rule show $NFS_SERVER_DOMAIN | wc -l`
{% raw %}
  if [ $EXIST -eq 0 ]; then
{% endraw %}
    ip rule add to $NFS_SERVER_DOMAIN table $ROUTING_TABLE_INT
  fi
}

# LB ONLY
# Setup public interface .network file
# Setup repairRoutes.sh
setup_public_interface() {
  # Does this machine have a public interface?
{% raw %}
  if [ ${#PUBLIC_IPS[@]} -eq 1 ]; then
    # Yes, setup route repair
    PRIVATEIP_COUNT=${#PRIVATE_IPS[@]}
{% endraw %}
    DEV_NAME=$(echo ${PUBLIC_IPS[0]} | awk '{print $4}')
    IP_INTERNAL=$(echo ${PUBLIC_IPS[0]} | awk '{print $1}')
    CIDR=$(echo ${PUBLIC_IPS[0]} | awk '{print $2}')
    CURRENT_GATEWAY=$(echo "$GATEWAYS" | awk -v pos=$(($PRIVATEIP_COUNT+1)) '{print $pos}')
    SUBNET_MASK=$(cidr_to_netmask $(echo ${PUBLIC_IPS[0]} | awk '{print $2;}'))
    NETWORK_ADDRESS=$(ip_to_netaddr $(echo ${PUBLIC_IPS[0]} | awk '{print $1;}') $(echo $SUBNET_MASK))
    { \
      echo '[Match]'; \
      echo 'Name='$DEV_NAME; \
      echo ''; \
      echo '[Network]'; \
      echo 'DHCP=no'; \
      echo 'DNS={{ NODE_NAMESERVER }}'; \
      echo 'Address='$IP_INTERNAL'/'$CIDR; \
      echo 'Gateway='$CURRENT_GATEWAY; \
      echo 'IPForward=kernel'; \
    } > /etc/systemd/network/1-$DEV_NAME.network
    echo "Writting 1-"$DEV_NAME".network"
    # Setup repairRoutes.sh
    DEV_INT=$(echo ${PRIVATE_IPS[0]} | awk '{print $4}')
    IP_INT=$(echo ${PRIVATE_IPS[0]} | awk '{print $1}')
    CIDR=$(echo ${PRIVATE_IPS[0]} | awk '{print $2}')
    SUBNET_MASK=$(cidr_to_netmask $(echo ${PRIVATE_IPS[0]} | awk '{print $2;}'))
    NETWORK_ADDRESS=$(ip_to_netaddr $(echo ${PRIVATE_IPS[0]} | awk '{print $1;}') $(echo $SUBNET_MASK))
    # Write repairRoutes.sh
    # Taken from Gerdi GIT (gerdikubed/util/sed.src/repairRoutes.sh)
    { \
      echo '#!/bin/bash'; \
      echo "ip route | egrep '"$DEV_INT"|br"$DEV_INT"' | \\" ; \
      echo 'while read line'; \
      echo 'do'; \
      echo '  ip route delete $line'; \
      echo 'done'; \
      echo ''; \
      echo 'ip rule add from '$IP_INT' lookup '$ROUTING_TABLE_INT; \
      echo 'ip rule add to '$NETWORK_ADDRESS'/'$CIDR' lookup '$ROUTING_TABLE_INT; \
      echo 'ip rule add to '$NFS_SERVER_DOMAIN' table '$ROUTING_TABLE_INT; \
      echo 'if service --status-all 2>&1 | grep -Fq 'dnsmasq'; then'; \
      echo '  service dnsmasq restart'; \
      echo 'fi'; \
    } > /root/repairRoutes.sh
    chmod +x /root/repairRoutes.sh
    { \
      echo '[Unit]'; \
      echo 'Description=Repair routes on multi NIC setup'; \
      echo 'After=network.target'; \
      echo ''; \
      echo '[Service]'; \
      echo 'ExecStart=/root/repairRoutes.sh'; \
      echo 'Type=oneshot'; \
      echo ''; \
      echo '[Install]'; \
      echo 'WantedBy=multi-user.target'; \
    } > /etc/systemd/system/repairRoutes.service
    systemctl enable --now repairRoutes.service > /dev/null 2>&1
    systemctl daemon-reload
{% raw %}
  elif [ ${#PUBLIC_IPS[@]} -gt 1 ]; then
{% endraw %}
    >&2 echo "Error: Too many public interfaces. I have no idea what to do!"
    exit 1;
  fi
}
{% endif %}

# Setup the private interface .network file
setup_private_interface() {
{% raw %}
  if [ ${#PRIVATE_IPS[@]} -eq 1 ]; then
{% endraw %} 
    # One private interfaces; First is gonna be SSH
    DEV_NAME=$(echo ${PRIVATE_IPS[0]} | awk '{print $4}')
    IP_INTERNAL=$(echo ${PRIVATE_IPS[0]} | awk '{print $1}')
    CIDR=$(echo ${PRIVATE_IPS[0]} | awk '{print $2}')
    NETWORK_ADDRESS=$(ip_to_netaddr $(echo ${PRIVATE_IPS[0]} | awk '{print $1;}') $(echo $SUBNET_MASK))
    CURRENT_GATEWAY=$(echo "$GATEWAYS" | awk -v pos="1" '{print $pos}')
    # Setup SSH interface
    { \
      echo '[Match]'; \
      echo 'Name='$DEV_NAME; \
      echo ''; \
      echo '[Network]'; \
      echo 'DHCP=no'; \
      echo 'DNS={{ NODE_NAMESERVER }}'; \
      echo 'Address='$IP_INTERNAL'/'$CIDR; \
      echo 'Gateway='$CURRENT_GATEWAY; \
      echo 'IPForward=kernel'; \
    } > /etc/systemd/network/$DEV_NAME.network
{% if inventory_hostname in groups['loadbalancer-nodes'] %}
{% raw %}
    if [ ${#PUBLIC_IPS[@]} -eq 1 ]; then
{% endraw %}
      # This is a 2 interface machine;
      # Get rid of previous Gateway
      sed -i '0,/Gateway=/{/Gateway=/d;}' /etc/systemd/network/$DEV_NAME.network
      # Append Route logic instead
      { \
        echo ''; \
        echo '[Route]'; \
        echo 'Gateway='$CURRENT_GATEWAY; \
        echo 'Table='$ROUTING_TABLE_INT; \
        echo ''; \
        echo '[Route]'; \
        echo 'Gateway='$CURRENT_GATEWAY; \
        echo 'Destination='$NETWORK_ADDRESS'/'$CIDR; \
        echo 'Table='$ROUTING_TABLE_INT; \
      } >> /etc/systemd/network/$DEV_NAME.network
      # Setup networkd for ovn kubernetes bridge
      cp /etc/systemd/network/$DEV_NAME.network /etc/systemd/network/br$DEV_NAME.network
      sed -i "s/Name=$DEV_NAME/Name=br$DEV_NAME/g" /etc/systemd/network/br$DEV_NAME.network
    fi
{% endif %}
    echo "Writting "$DEV_NAME".network"
  else
    >&2 echo "Error: Too many private interfaces. I have no idea what to do!"
    exit 1;
  fi
}

# Replaces networking.service and resolv.conf with 
# systemd-networkd and systemd-resolved (required for our two interface setup)
replace_networking() {
  # Delete previous resolve file
  rm /etc/resolv.conf
  # Start systemd networking
  systemctl enable --now systemd-networkd.service > /dev/null 2>&1
  systemctl enable --now systemd-resolved.service > /dev/null 2>&1
  # Disable previous networking
  systemctl disable networking.service > /dev/null 2>&1
  # Setup systemd DNS
  # Make sure to add our DNS
  sed -i 's/#DNS=/DNS={{ NODE_NAMESERVER }}/;' /etc/systemd/resolved.conf
  # Link our new resolv.conf to the right place
  ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
  # Reload services
  systemctl daemon-reload
  systemctl restart systemd-resolved.service > /dev/null 2>&1
  systemctl restart systemd-networkd > /dev/null 2>&1
}

# Setup sshd to listen to the right interface
setup_sshd_ip() {
  # We always use the private IP for SSH
  IP_INT=$(echo ${PRIVATE_IPS[0]} | awk '{print $1}')
  sed -i 's/#ListenAddress 0.0.0.0/ListenAddress '$IP_INT'/
    s/#AddressFamily.*/AddressFamily inet/;' /etc/ssh/sshd_config
}

Main() {
  clean_vmware_netconfig
  check_if_already_setup
  validate_input_parameters
  build_ip_arrays
  validate_ip_count
{% if inventory_hostname in groups['loadbalancer-nodes'] %}
  add_nfs_ip_rule
  setup_public_interface
{% endif %}
  setup_private_interface
  replace_networking
  setup_sshd_ip
}

##########################
# BEGINNING OF EXECUTION #
##########################

# Assign input parameters
ROUTING_TABLE_INT=$1
NFS_SERVER_DOMAIN=$2

# Declare global arrays
PUBLIC_IPS=()
PRIVATE_IPS=()
GATEWAYS=()

# Execute Main
Main
